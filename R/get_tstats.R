#' Get t-Statistics
#'
#' This function calculates a moderated t-Statistic per site or tuple using
#' \code{limma}'s \code{\link{lmFit}} and \code{\link{eBayes}} functions. It
#' then smoothes the obtained t-Statistics using \code{bumphunter}'s
#' \code{\link{smoother}} function.
#'
#' The smoothing is done on genomic clusters consisting of CpGs that are close
#' to each other. In the case of tuples, the midpoint of the two genomic
#' positions in each tuple is used as the genomic position of that tuple, to
#' perform the smoothing.The function takes a \code{RangedSummarizedExperiment}
#' generated by \code{\link{calc_derivedasm}} or \code{\link{calc_asm}}
#' containing ASM across samples, and the index of control and treatment
#' samples.
#'
#' @param sa A SummarizedExperiment containing ASM values where each row and
#'   column correspond to a tuple/site and sample respectively.
#' @param design a design matrix created with \code{\link{model.matrix}}.
#' @param coef Column in model.matrix specifying the parameter to estimate.
#'   Default = 2.
#' @param method The method to be used in limma's \code{\link{lmFit}}. The
#'   default is set to "ls" but can also be set to "robust", which is
#'   recommended on a real data set.
#' @param smooth Whether smoothing should be applied to the t-Statistics.
#'   Default = TRUE
#' @param maxGap The maximum allowed gap between genomic positions for
#'   clustering of genomic regions to be used in smoothing. Default = 20.
#' @param verbose Set verbose. Default = TRUE.
#' @param ... Arguments passed to \code{\link{loessByCluster}}. Only used if
#'   \code{smooth} = TRUE.
#'
#' @return A vector of t-Statistics within the
#'   \code{RangedSummarizedExperiment}.
#' @importFrom BiocGenerics start
#' @importFrom SummarizedExperiment assays
#'
#' @export
#' @examples

get_tstats <- function(sa, design, method="ls", smooth = TRUE, maxGap=300, 
                       coef=2, verbose=TRUE, ...) {

  # choose SumExp type
  if(names(assays(sa))[1] == "asm"){
    asm <- assays(sa)[["asm"]]
  } else {
    asm <- assays(sa)[["der.ASM"]]
  }

  # moderated t-statistic using specified column in the design matrix
  if(verbose) message("Calculating moderated t-statistics", appendLF = TRUE)
  fit <- limma::lmFit(object = asm, design = design, method = method)
  fit2 <- limma::eBayes(fit)
  S4Vectors::mcols(sa)$tstat <- fit2$t[,coef]
  S4Vectors::mcols(sa)$p.value <- fit2$p.value[,coef]
  

  if(names(assays(sa))[1] == "asm"){
    midpt <- S4Vectors::mcols(sa)$midpt
  } else {
    midpt <- start(sa)
  }

  S4Vectors::mcols(sa)$cluster <- bumphunter::clusterMaker(
    chr = as.character(GenomeInfoDb::seqnames(sa)),
    pos = midpt, 
    maxGap = maxGap,
    assumeSorted = TRUE)
  
  # smooth moderated t-stats
  if(smooth){
    
    if(verbose) message("Smoothing moderated t-statistics", appendLF = TRUE)
    
    smooth <- bumphunter::loessByCluster(
      y = S4Vectors::mcols(sa)$tstat, 
      x = midpt,
      cluster = S4Vectors::mcols(sa)$cluster,
      # bpSpan = bpSpan,
      #minNum = 2, 
      #minInSpan = 2, 
      # maxSpan = maxSpan,
      # verbose = verbose,
      ...)
    
    S4Vectors::mcols(sa)$smooth_tstat <- smooth$fitted[,1]
    
    sa <- sa[!is.na(S4Vectors::mcols(sa)$smooth_tstat),]
  } 
  #filter for empty tstats (?)
  sa <- sa[!is.na(S4Vectors::mcols(sa)$tstat),]
  return(sa)
}
