#' Calculate SNP-based ASM
#'
#' Combines all the \emph{GRangeslist} generated in \code{\link{split_bams}} into a
#' \code{\link[SummarizedExperiment]{SummarizedExperiment}} object, and calculates
#' SNP-based allele-specific methylation.
#' TODO: Make accesor functions to all the assays in this object
#'
#' @param rds_files list of .rds files generated by \code{\link{split_bams}}.
#' @param cores Number of cores to thread.
#' @param verbose If the function should be verbose.
#' @return SummarizedExperiment containing in assays: (FIX)
#' - der.ASM = matrix with SNP-based ASM
#' - snp.table = Matrix with SNP associated to the CpG site
#' - ref.cov = Coverage of the "reference" allele
#' - alt.cov = Coevarage of the "alternative" allele
#' - ref.meth = Methylated reads from the "reference" allele
#' - alt.meth = Methylated reads from the "alternative" allele
#'
#' @examples
#'
#' @importFrom S4Vectors mcols
#' @importFrom GenomicRanges GRanges
#' @importFrom IRanges IRanges
#'
#' @export

calc_derivedasm <- function(rds_files, cores = 1, verbose = T){

  #filter duplicated sites and choose the one with the highest meth.diff
  allGR <- parallel::mclapply(rds_files, function(r){
    if(verbose) message(".", appendLF=FALSE)
    load(r)

    #remove NULL values from list
    snp.table <- plyr::compact(snp.table)

    #Create a (actual) granges list, to be able to unlist
    GRlist <- GenomicRanges::GRangesList(snp.table)
    w <- unlist(GRlist)

    #calculate meth.diff
    prop.alt <- mcols(w)$meth.alt / mcols(w)$cov.alt
    prop.ref <- mcols(w)$meth.ref / mcols(w)$cov.ref
    mcols(w)$meth.diff <- abs(prop.alt - prop.ref)

    #transform to keys
    full.keys <- paste0(seqnames(w),'.',start(w))

    #get unique ranges to loop
    unique.keys <- unique(sort(full.keys))

    #For duplicate sites, choose the one with the highest meth.diff
    cols <- vapply(unique.keys, function(x){
      #cols <- vapply(unGR, function(x){
      sHits <- as.integer(match(x,full.keys))

      if(length(sHits) <= 1){
        return(as(mcols(w)[sHits,], "matrix"))
      } else{
        methdiffs <- mcols(w)$meth.diff[sHits]
        high <- as.integer(which.max(methdiffs))
        return(as(mcols(w)[sHits[high],], "matrix"))
      }
    }, character(6))

    #the vapply returns a tranversed matrix with everything as characters, so I have to transform this.
    mcol <- data.frame(as.numeric(cols[1,]),
                       as.numeric(cols[2,]),
                       as.numeric(cols[3,]),
                       as.numeric(cols[4,]),
                       cols[5,],
                       as.numeric(cols[6,]),
                       stringsAsFactors = F
    )
    colnames(mcol) <- colnames(mcols(w))
    ss <- limma::strsplit2(unique.keys,".",fixed=TRUE)

    #human ordering
    or <- GenomeInfoDb::orderSeqlevels(ss[,1])

    #return GRanges
    unGR <- GRanges(ss[,1][or], IRanges(as.integer(ss[,2][or]), width = 1))
    mcols(unGR) <- mcol[or,]

    #The unGR has the filtered sites for this sample
    return(unGR)
  }, mc.cores = cores)

  #Try to extract from all the GRanges the unique sites by generating a key
  all_keys <- lapply(allGR, function(u) {
    if(verbose) message(".", appendLF=FALSE)
    paste0(seqnames(u),'.',start(u))
  })

  key <- unique(unlist(all_keys))
  ss <- limma::strsplit2(key,".",fixed=TRUE)
  keyGR <- GRanges(ss[,1], IRanges(as.numeric(ss[,2]), width =1))

  # get matrix of scores across all samples
  trueASM_table <- mapply( function(df,k){
    if(verbose) message(".", appendLF=FALSE)
    m <- match(key, k)
    mcols(df)$meth.diff[m]
  }, allGR, all_keys)

  rownames(trueASM_table) <- key

  # Get matrices of coverages
  ref.cov_table <- mapply( function(df,k){
    if(verbose) message(".", appendLF=FALSE)
    m <- match(key, k)
    return(mcols(df)$cov.ref[m])
  }, allGR, all_keys)

  alt.cov_table <- mapply( function(df,k){
    if(verbose) message(".", appendLF=FALSE)
    m <- match(key, k)
    return(mcols(df)$cov.alt[m])
  }, allGR, all_keys)

  ref.meth_table <- mapply( function(df,k){
    if(verbose) message(".", appendLF=FALSE)
    m <- match(key, k)
    return(mcols(df)$meth.ref[m])
  }, allGR, all_keys)

  alt.meth_table <- mapply( function(df,k){
    if(verbose) message(".", appendLF=FALSE)
    m <- match(key, k)
    return(mcols(df)$meth.alt[m])
  }, allGR, all_keys)


  # Get matrix for snp ID
  snp_match_table <- mapply( function(df,k){
    if(verbose) message(".", appendLF=FALSE)
    m <- match(key, k)
    mcols(df)$snp[m]
  }, allGR, all_keys)

  if(dim(snp_match_table) != dim(trueASM_table)){
    stop("Tables contain different sizes")
  }

  #filter sites with a lot of NAs and 0s
  keep <- BiocGenerics::rowSums(!is.na(trueASM_table) & trueASM_table > 0) >= length(allGR)
  trueASM_table <- trueASM_table[keep,]
  snp_match_table <- snp_match_table[keep,]
  ref.cov_table <- ref.cov_table[keep,]
  alt.cov_table <- alt.cov_table[keep,]
  ref.meth_table <- ref.meth_table[keep,]
  alt.meth_table <- alt.meth_table[keep,]
  keyGR <- keyGR[keep]

  if(dim(snp_match_table) != dim(trueASM_table)){
    stop("Tables contain different sizes")
  } else{
    message("Returning %i CpG sites for %i samples",  dim(trueASM_table)[1], dim(trueASM_table)[2])
  }

  ##Put all matrices into S4 vector
  derived_ASM_matrix <- SummarizedExperiment::SummarizedExperiment(assays=S4Vectors::SimpleList(der.ASM = trueASM_table,
                                                                         snp.table = snp_match_table,
                                                                         ref.cov = ref.cov_table,
                                                                         alt.cov = alt.cov_table,
                                                                         ref.meth = ref.meth_table,
                                                                         alt.meth = alt.meth_table),
                                                   rowRanges=keyGR)

  return(derived_ASM_matrix)
}

