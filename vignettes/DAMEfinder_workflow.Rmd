---
title: "DAMEfinder Workflow"
author: 
- name: Stephany Orjuela
  email: sorjuelal@gmail.com
- name: Dania Machlab
  email: dania.machlab@gmail.com
- name: Mark Robinson
  email: mark.robinson@imls.uzh.ch
date: "`r Sys.Date()`"
package: DAMEfinder
output: 
  BiocStyle::html_document
vignette: >
  %\VignetteIndexEntry{DAMEfinder Workflow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8} 
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache = 0, fig.path = "figure/", fig.width = 6, fig.height = 7)
```

```{r style, echo = FALSE, results = 'asis'}
BiocStyle::markdown()
```


# DAMEfinder Overview

*something about ASM, types of ASM, humans bla bla. also something about BS-seq (take it from the proposal?)*. We focus on cases of ASM in which there is an imbalance in the methylation level between two alleles.

DAMEfinder runs in two modes: **SNP-based** (exhaustive-mode) and **tuple-based** (fast-mode), which come together when differential methylation is identified: 

```{r, echo=FALSE, out.width='250%', fig.align='center'}
knitr::include_graphics('DAMEfinder_workflow.png')
```

## Get bam files
In order to run any of the two modes, you must obtain aligned `bam` files using [`bismark`](http://www.bioinformatics.babraham.ac.uk/projects/bismark/). Here we demonstrate how to generate these starting from paired-end `fastq` files of bisulfite-treated reads:

```{bash eval=FALSE}
#Check quality of reads
fastqc -t 2  sample1_R1.fastq.gz sample1_R2.fastq.gz
	
#Trim reads to remove bad quality regions and adapter sequence
trim_galore --paired sample1_R1.fastq.gz sample2_R2.fastq.gz
```

To trim the reads we use [`Trim Galore`](https://github.com/FelixKrueger/TrimGalore) and specify the use of paired reads. By default it will remove any adapter sequence it recognizes. Please refer to the [user guide](https://github.com/FelixKrueger/TrimGalore/blob/master/Docs/Trim_Galore_User_Guide.md) for further specifications.

```{bash eval=FALSE}
#Build bisulfite reference 
bismark_genome_preparation <path_to_genome_folder>

#run Bismark
bismark -B sample1 --genome <path_to_genome_folder> -1 sample1_R1_val_1.fq.gz -2 sample1_R2_val_2.fq.gz

#deduplicate (optional)
deduplicate_bismark -p --bam sample1_pe.bam

#sort and index files
samtools sort -m 20G -O bam -T _tmp -o sample1_pe.dedupl_s.bam sample1_pe.deduplicated.bam
samtools index file1_pe.dedupl_s.bam
```

Before the alignment, you must download a reference fasta file from [Ensembl](https://www.ensembl.org/info/data/ftp/index.html) or [Gencode](https://www.gencodegenes.org/), and generate a bisulfite converted reference. For this we use `bismark_genome_preparation` from the `bismark` suite, and specify the folder that contains the `fasta` file with its index file.
Depending on the library type and kit used to obtains the reads, you may want to deduplicate your bam files (e.g. TruSeq). Please refer to the [user guide](https://rawgit.com/FelixKrueger/Bismark/master/Docs/Bismark_User_Guide.html) for further explanation and specifications.


# SNP-based (aka slow-mode)

To run the SNP-based mode, you need to additionally have a `VCF` file including the heterozygous SNPs per sample. If you do not have this, we recommend using the tuple-based mode, or running [`Bis-SNP`](http://people.csail.mit.edu/dnaase/bissnp2011/) to obtain variant calls from bisulfite-converted reads. 
?include example to run Bis-SNP?

## Example Workflow 

In this example we use a dataset from (cite serrated paper). We include samples from two patients with colo-rectal cancer. For each patient two samples were taken: `NORM#` corresponds to normal mucosa tissue and `CRC#` corresponds to the paired adenoma lesion. Each of these samples was sequenced using targeted BS-seq followed by variant calling using `Bis-SNP`.

### Obtain allele-based methylation calls

Similar to the `bismark_methylation_extractor`, we obtain methylation calls. However since we are interested in allele-specific methylation, we only extract methylation for CpG sites that fall within reads including a SNP. For every SNP in the `VCF` file an independent methylation call is performed by using `split_bams`, which "splits" reads from the `BAM` file according to the alleles:

```{r}
library(DAMEfinder)

bam_files <- c(system.file("extdata", "NORM1_chr19.bam", package = "DAMEfinder"),
               system.file("extdata", "CRC1_chr19.bam", package = "DAMEfinder"))

vcf_files <- c(system.file("extdata", "NORM1.chr19.moretrim.vcf", package = "DAMEfinder"),
               system.file("extdata", "CRC1.chr19.moretrim.vcf", package = "DAMEfinder"))

sample_names <- c("NORM1", "CRC1")

reference_file <- system.file("extdata", "19.fa", package = "DAMEfinder")

#Split reads and extract methylation according to allele
split_bams(bam_files, vcf_files, sample_names, reference_file)

#Read in one of the generated files
snp.table <- readRDS("snp.table.NORM1.rds")

#CpG sites for first SNP in VCF file
snp.table[[1]]

#CpG sites for second SNP in VCF file
snp.table[[2]]

#And so on...
```


For demonstration, we include `BAM` files from chromosome 19, and `VCF` files with 43 SNPs. Typically we would run the function on an entire `BAM` and `VCF` file, which would generate a large output and occupy a lot of memory. Because of this we save the output in an `.rds` file for each sample as `snp.table.<sample_name>.rds`.

The function also takes as input the reference file used to generate the alignments. For demonstration we use chromosome 19 of the `GRCh37.91` reference fasta file.

### Summarize methylation calls across samples

Typically you won't have to deal with the `.rds` files, because we have a function that reads in all the files generated by `split_bams()` and summarizes all the necesarry information into a `SummarizedExperiment` object:

```{r}

rds_files <- list("snp.table.NORM1.rds", "snp.table.CRC1.rds")
derASM <- calc_derivedasm(rds_files)

derASM
```

Every row in the object is a single CpG site, and each column a sample. It contains 6 matrices in `assays`:

* der.ASM: Derived SNP-based ASM: $abs(\frac{X^{r}_M}{X^{r}} - \frac{X^{a}_M}{X^{a}})$

* snp.table: Location of the SNP associated to the CpG site

* ref.cov: Coverage of the "reference" allele

* alt.cov: Coevarage of the "alternative" allele

* ref.meth: Methylated reads from the "reference" allele

* alt.meth: Methylated reads from the "alternative" allele

You can access these assays as:

```{r}
suppressPackageStartupMessages(library(SummarizedExperiment))

head(assays(derASM)[["der.ASM"]])

```

### Get t-Statistics per site TODO

Next, we obtain a moderated t-statistic per CpG site using `limma`. The statistic reflects a measure of difference between the two conditions being compared, in this case normal Vs cancer. The t-Statistic is smoothed using `bumphunter`.

For each condition being compared, we recommend at least three biological replicates. This ensures enough biological variability to calculate residual degrees of freedom in the linear model fit.

```{r, eval=FALSE}

# Make a design matrix that specifies the two conditions per sample
cols <- rep(1,ncol(derASM))
n <- grep("NORM", colnames(derASM))
cols[n] <- 0

mod <- matrix(data=c(rep(1,ncol(derASM)), cols), ncol = 2)
mod

# Get t-Statistics
tStatistics <- get_tstats(derASM, mod, method = "ls")

```

### Find DAMEs

Finally, we detect regions that show differential ASM. We provide a wraper of the `regionFinder()` function from `bumphunter`, and specify a cutoff as the Qth quantile of the absolute values of the given smoothed t-Statistics. 

```{r, eval=FALSE}

dames <- find_dames(tStatistics, Q=0.9, maxGap=20)

head(dames)

```



# tuple-based (aka fast-mode)

Before running the tuple-based mode, you must obtain files from the `methtuple` tool to input them in the `read_tuples` function.


## Run Methtuple on bam files

Methtuple requires the input `BAM` files of paired-end reads to be sorted by query name. For more information on the options in `methtuple`, refer to the user [guide](https://github.com/PeteHaitch/methtuple). For example the `--sc` option combines strand information.

```{bash, eval=FALSE}

# Sort bam file by query name
samtools sort -n -@ 10 -m 20G -O bam -T _tmp -o sample1_pe_sorted.bam sample1_pe.deduplicated.bam

# Run methtuple
methtuple --sc --gzip -m 2 sample1_pe_sorted.bam
```


## Example Workflow 

### Read methtuple files 

We use the same samples as above to run `methtuple` and obtain `.tsv.gz` files. We read in these files using `read_tuples` and obtain a list of `tibble`s, each one for every sample:

```{r}
tuple_files <- c(system.file("extdata", "NORM1_chr19_qs.CG.2.tsv.gz", package = "DAMEfinder"),
                 system.file("extdata", "CRC1_chr19_qs.CG.2.tsv.gz", package = "DAMEfinder"))


tuple_list <- read_tuples(files = tuple_files, sample_names)

head(tuple_list$NORM1)
```

Each row in the `tibble` displays a tuple. The chromosome name and strand are shown followed by `pos1` and `pos2` which refer to the genomic positions of the first and second CpG in the tuple. The `MM`, `MU`, `UM`, and `UU` counts of the tuple are displayed where `M` stands for methylated and `U` for unmethylated. For example, `UM` shows the read counts for the instances where `pos1` is unmethylated and `pos2` is methylated. The coverage and distance between the two genomic positions in the tuple are shown under `cov` and `inter_dist` respectively.


### Calculate ASM Score

The calc_asm function takes in the output from `read_tuples()` and outputs a `SummarizedExperiment` where each row is a tuple and each column is a sample. As in the SNP-based mode, the object contains 6 assays including the `MM`, `MU`, `UM`, and `UU` counts, as well as the total coverage and the tuple-based ASM score. 

This score is a measure ASM calculated directly from the reads without the need of SNP information. Because of this it is a lot quicker than the SNP-based ASM, and is useful for more explorative questions. Equations \@ref(eq:asmGeneral), \@ref(eq:asmWeight) and \@ref(eq:asmTheta) show how the score is calculated. The log odds ratio in equation \@ref(eq:asmGeneral) provides a higher score the more `MM` and `UU` counts the tuple has, whereas a higher `UM` and `MU` would indicate "random" methylation. The weight further adds allele-specificity where a rather balanced MM:UU count provides the tuple with a higher score.

\begin{equation}
    ASM^{(i)} = log{ \Big\{ \frac{X_{MM}^{(i)} \cdot X_{UU}^{(i)}}{X_{MU}^{(i)} \cdot X_{UM}^{(i)}} \Big\} \cdot w_i }
    (\#eq:asmGeneral)
\end{equation}

\begin{equation}
    w_i = P(0.5-\epsilon < \theta < 0.5+\epsilon~|~ X_{MM}^{(i)}, X_{UU}^{(i)}, \beta_1, \beta_2)
    (\#eq:asmWeight)
\end{equation}

\begin{equation}
    \theta^{(i)} | X_{MM}^{(i)}, X_{UU}^{(i)},\beta_1, \beta_2 \sim Beta(\beta_1+X_{MM}^{(i)}, \beta_2+X_{UU}^{(i)})
    (\#eq:asmTheta)
\end{equation}


where $\theta^{(i)}$ represents the moderated proportion of MM to MM+UU alleles. The weight, $w_i$ is set such that the observed split between MM and UU alleles can depart somewhat from 50/50, while fully methylated or unmethylated tuples, which represents evidence for absence of allele-specificity, are attenuated to 0.  The degree of allowed departure can be set according to $\epsilon$, the deviation from 50/50 allowed and the level of moderation, $\beta_1$ and $\beta_2$.

```{r}

ASM_mat <- calc_asm(sample_list = tuple_list)
ASM_mat
```



*At this point, the user may want to remove rows (tuples) in the ASM_score_matrix, where all samples of one condition have NA values. One can also set a minimum number of samples to have counts per tuple as a further restriction. However, removing tuples that have NA values in all samples of a particular condition is a necessary step.*

*TODO: add this to the function*

### Remove tuples without a SNP

Some of the tuples obtained above might have a good ASM score, however in some cases, this is no guarantee that the ASM is linked to an actual SNP. Because of this and to reduce the number of false positives, you can remove CpG sites that are "far away" from a SNP. Since in the **tuple-based mode** we assume you do not have `VCF` files of your samples, what you can get is a common set of variants. 

Here we include some options to obtain such a `VCF` file:

* From [dbSNP](https://www.ncbi.nlm.nih.gov/variation/docs/human_variation_vcf/), or its [ftp site](ftp://ftp.ncbi.nih.gov/snp/organisms/human_9606_b150_GRCh37p13/VCF/).
* From [ensembl](http://www.ensembl.org/info/data/ftp/index.html), or its [ftp site](ftp://ftp.ensembl.org/pub/grch37/release-91/variation/vcf/homo_sapiens/).

Next, you can load that file into R with `vcfR`. For more info on this package click [here](https://knausb.github.io/vcfR_documentation/index.html):

```{r, eval =F}
library(vcfR)
vcf <- read.vcfR("../../Shared_taupo/steph/reference/common_all_20170710.vcf")
vcf <- getFIX(vcf)
```

This way we get a matrix version of the `VCF` file. 

Next we make a GRanges object from the vcf, and extract the GRanges from the SummarizedExperiment.

```{r, eval=FALSE}

GRvcf <- GRanges(vcf[,1],IRanges(as.numeric(vcf[,2]), width = 1))
rm(vcf) #because it's too heavy

GRasm <- rowRanges(ASM_mat)
```

Since we want to keep tuples within a certain proximity of a variant, we grab 50 base pairs up and downstream from the SNP and filter the SummarizedExperiment to keep the CpG tuples within this window. You can change the size of the window depending on for example the read lenght in your data:

```{r, eval=FALSE}

#Set 100 bp window (read length) from the SNP
GRvcf <- GenomicRanges::promoters(GRvcf, upstream=50, downstream=50)

#Filter tuples 
over <- GenomicRanges::findOverlaps(GRasm, GRvcf)
ASM_mat <- ASM_mat[unique(S4Vectors::queryHits(over)),]
```


### Get t-Statistics per tuple and obtain DAMEs

As above, the `SummarizedExperiment` is used to detect differential ASM:

```{r, eval=FALSE}

tStatistics <- get_tstats(ASM_mat)

dames <- find_dames(tStatistics, Q=0.9, maxGap=20)

head(dames)
```


# Visualization

## Methyl-circle plot

A typical way of visualizing ASM is to look at the reads overlapping a particular SNP, and the methylation state of the CpG sites in those reads (black circles for methylated and white for unmethylated) (See example [here](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2892089/)). Here we offer this option with the function `methyl_circle_plot()`. As input it takes a GRanges with the SNP of interest, and the `BAM`, `VCF` and reference files as in the `split_bams()` function.

```{r, fig1}
library(GenomicRanges)
snp <- GRanges(19, IRanges(267039, width = 1))

snp

bam.file <- system.file("extdata", "NORM1_chr19.bam", package = "DAMEfinder")

vcf.file <- system.file("extdata", "NORM1.chr19.moretrim.vcf", package = "DAMEfinder")

ref.file <- system.file("extdata", "19.fa", package = "DAMEfinder")

methyl_circle_plot(snp = snp, vcf.file = vcf.file, bam.file = bam.file, ref.file = ref.file, sample.name = "sample1")
```

If you are interested in a specific CpG site within this plot, you can include an extra GRanges with its location:

```{r, fig2}

cpgsite <- GRanges(19, IRanges(266998, width = 1))

methyl_circle_plot(snp = snp, vcf.file = vcf.file, bam.file = bam.file, ref.file = ref.file, sample.name = "sample1", cpgsite = cpgsite)
```

If you are instead interested in reads overlapping a CpG site, you can use an alternative function
```{r, fig3}

cpgsite <- GRanges(19, IRanges(266998, width = 1))

methyl_circle_plotCpG(cpgsite = cpgsite, bam.file = bam.file, ref.file = ref.file)
```

TODO: You can also limit both the SNP plot and the CpG plot to a specific window of interest (to zoom in or out), say for example after you have identified a DAME.

## Multi-sample visualization

TODO: You can generate `bigWig` files for each sample, containing either the SNP-based or the tuple-based scores by running *a function*.

TODO: You can also plot these scores using *another function* for a specific region or an identified DAME of interest.
