---
title: "DAMEfinder Workflow"
author: 
- name: Dania Machlab
  email: dania.machlab@gmail.com
- name: Mark Robinson
  email: mark.robinson@imls.uzh.ch
package: DAMEfinder
output: 
  BiocStyle::html_document2
vignette: >
  %\VignetteIndexEntry{DAMEfinder Workflow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8} 
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

```

```{r style, echo = FALSE, results = 'asis'}
BiocStyle::markdown()
```


# DAMEfinder Overview

## Bumphunting

# Prerequisites

The differential allele-specific methylation analysis using DAMEfinder starts at the level of the methtuple files. The user must have obtained a list of the files resluting from the methtuple tool to input them in the read_tuples function.

## Illustrative code on how to get from fastq files to the methtuple files level

The DAMEfinder package can be used for detection of differentially allele-specifically methylated regions starting from the files given by the methtuple tool. These files contain unique CpG tuple counts for each sample. We demonstrate how to get to this point starting from fastq files of bisulfite treated reads. 

### Mapping bisulfite reads

? mention other tools for mapping BSseq reads.
Bismark is used to map BS-seq reads to a reference genome. The reads may be trimmed before this step, based on the results of the quality control done on them. If so, then the trimmed reads are mapped using bismark as follows. In the example below, we map the PE reads of sample1 and show other the use of other helpful functions in bismark to exctract  methylation information that may be used later in the analysis.

```{bash eval=FALSE}
# map BS-seq reads
bismark --bowtie2 -p 4 -o aligned_sample1 path_to_reference_genome -1 sample1_R1.fastq.gz -2 sample1_R2.fastq.gz

# remove duplicates
$ deduplicate_bismark  -p aligned_sample1_bismark_bt2_pe.sam






# create sorted bam files
samtools view -Sb aligned_sample1_bismark_bt2_pe.sam >  aligned_sample1_bismark_bt2_pe.bam;
samtools sort aligned_sample1_bismark_bt2_pe.bam aligned_sample1_bismark_bt2_pe_sorted;
samtools index aligned_sample1_bismark_bt2_pe_sorted.bam;







# bismark methylation extractor

bismark_methylation_extractor -p --comprehensive sim_adenoma1_R1.fastq_bismark_bt2_pe.sam;
bismark2bedGraph --counts -o CpG_context_sim_adenoma1_R1.fastq_bismark_bt2_pe.bedGraph CpG_context_sim_adenoma1_R1.fastq_bismark_bt2_pe.txt;

# remove duplicates
deduplicate_bismark -p output_sample1.sam 
 
# run methylation_extractor 
bismark_methylation_extractor -p --comprehensive NGS-2852_0316_L001_0347_L005_R1_paired.fastq.gz_bismark_bt2_pe.deduplicated.sam


# create sorted bam files



```


### Run Methtuple on bam files

After mapping the BS-seq reads and obtaining the resulting bam files, we can run methtuple. Methtuple requires the input bam files of PE reads to be sorted by query name. For more information on the options in methtuple, refer to the manual of the software. There is the option, for example, of sckipping a number of bases from either end of each read. This is usefult to avoid the first few bases that show methylation bias. The --sc option combines strand information.

```{bash eval=FALSE}

# Sort bam file by query name
samtools sort -n -@ 10 -m 20G -O bam -T _tmp -o QS_sim_adenoma1_R1.fastq_bismark_bt2_pe_sorted.bam sim_adenoma1_R1.fastq_bismark_bt2_pe_sorted.bam

# Run methtuple
methtuple --sc --gzip -m 2 QS_sim_adenoma1_R1.fastq_bismark_bt2_pe_sorted.bam 

```


# Example Workflow 

We demonstrate an application of DAMEfinder using the example data set found in the package.

## Read methtuple files 

We copy all the files available in the extdata folder of the package which contains the methtuple files we will use in this example. The files are the result of simulated data and encompass a small section of chr14 and contain allele-scpecifically methylated regions in the normal samples, some of which are lost in the adenoma samples.



```{r}
library(DAMEfinder)

file.copy(system.file(package="DAMEfinder", "extdata"), ".", recursive=TRUE)
meta_data <- read.table("extdata/metadata.txt", header = TRUE)
file_list <- list.files(path = "extdata/", pattern = ".tsv.gz")
m <- match(file_list, meta_data$methtuplefile)
file_list <- paste0("extdata/", file_list)
names(file_list) <- meta_data$shortname[m]

file_list

```

```{r}

sample_list <- read_tuples(files = file_list, sample_names = names(file_list))

head(sample_list$"adenoma1")

```

read_tuples returns a list of data frames, with each data frame corresponding to one sample. Each row in the data frame displays a tuple. The chromosome name and starnd are shown followed by pos1 and pos2 which refer to the genomic positions of the first and second CpG in the tuple. The MM, MU, UM, and UU counts of the tuple are displayed where M stands for methylated and U for unmethylated. For example, UM shows the read counts for the instances where pos1 is unmethylated and pos2 is methylated. The cover and distance between the two genomic positions in the tuple are shown under "cov" and "inter_dist" respectively.

### Remove SNPs

On a real data set, tuples that contain CpGs corresponding to SNPs ought to be removed using the remove_snps function. Since the example data set is a simulated one, there is no need to apply the step in our workflow. We demonstrate the use of the function below. A snp_key must be supplied as input, which contains all the SNPs in the following form: 'chr.position.'. For example, "chr5.7382".

suggestiong for future: specifiy the genome only and have the function produce the snp_key

```{r eval=FALSE}

sample_list_no_snps <- parallel::mclapply(sample_list, remove_snps, mc.cores=6)
```


## Calculate ASM Score

The calc_asm function takes in the list of samples and outputs a matrix where each row is a tuple and each column is a sample. This matrix contains allele-specific methylation (ASM) scores. The ASM score is a measure of the extent of allele-specific methylation. Equations \@ref(eq:asmGeneral), \@ref(eq:asmWeight) and \@ref(eq:asmTheta) show how the score is calculated. The log odds ratio in equation \@ref(eq:asmGeneral) provides a higher score, the more MM and UU counts the tuple has, rather than random methylations of UM and MU. The weight further adds allele-scpecificity where a rather balanced MM:UU count provides the tuple with a higher score.

\begin{equation}
    ASM^{(i)} = log{ \Big\{ \frac{X_{MM}^{(i)} \cdot X_{UU}^{(i)}}{X_{MU}^{(i)} \cdot X_{UM}^{(i)}} \Big\} \cdot w_i }
    (\#eq:asmGeneral)
\end{equation}

\begin{equation}
    w_i = P(0.5-\epsilon < \theta < 0.5+\epsilon~|~ X_{MM}^{(i)}, X_{UU}^{(i)}, \beta_1, \beta_2)
    (\#eq:asmWeight)
\end{equation}

\begin{equation}
    \theta^{(i)} | X_{MM}^{(i)}, X_{UU}^{(i)},\beta_1, \beta_2 \sim Beta(\beta_1+X_{MM}^{(i)}, \beta_2+X_{UU}^{(i)})
    (\#eq:asmTheta)
\end{equation}


where $\theta^{(i)}$ represents the moderated proportion of MM to MM+UU alleles. The weight, $w_i$ is set such that the observed split between MM and UU alleles can depart somewhat from 50/50, while fully methylated or unmethylated tuples, which represents evidence for absence of allele-specificity, are attenuated to 0.  The degree of allowed departure can be set according to $\epsilon$, the deviation from 50/50 allowed and the level of moderation, $\beta_1$ and $\beta_2$.  For example, the degree of mixture of subpopulations may play a role (e.g., allele-specificity may not happen on all subpopulations).




```{r}

ASM_score_matrix <- calc_asm(sample_list = sample_list)

```


At this point, the user may want to remove rows (tuples) in the ASM_score_matrix, where all samples of one condition have NA values. One can also set a minimum number of samples to have counts per tuple as a further restriction. However, removing tuples that have NA values in all samples of a particular condition is a necessary step.

comment: add this to the function?

## Get t-Statistics per tuple

Next, we obtain a moderated t-statistic per tuple that reflects a measure of difference between the two conditions being comapred. The t-Statistic is smoothed using smoother function from bumphunter. The midpoint of the two positions in each tuple is set as the genomic position of every tuple in the smoothing process.

```{r}

# Make a design matrix that specifies the two conditions per sample
cols <- rep(1,ncol(ASM_score_matrix))
n <- grep("normal", colnames(ASM_score_matrix))
cols[n] <- 0

mod <- matrix(data=c(rep(1,ncol(ASM_score_matrix)), cols), ncol = 2)
mod

# Get t-Statistics
tStatistics <- get_tstats(ASM_score_matrix, mod, method = "ls")

```

## Find DAMEs

Finally, we detect regions that show differential allele-specific methylation. The regionFinder function from bumphunter is used in this process. cutoff explain how it's set

```{r}

dames <- find_dames(tStatistics)

head(dames)

```


<!-- ## R Markdown -->

<!-- This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>. -->

<!-- When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this: -->

<!-- ```{r cars} -->
<!-- summary(cars) -->
<!-- ``` -->

<!-- ## Including Plots -->

<!-- You can also embed plots, for example: -->

<!-- ```{r pressure, echo=FALSE} -->
<!-- plot(pressure) -->
<!-- ``` -->

<!-- Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot. -->
